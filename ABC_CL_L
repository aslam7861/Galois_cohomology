 N := OptimizedRepresentation(Compositum(L,L1));
    assert IsTotallyReal(N);
    ON := RingOfIntegers(N);

    Gamma, _ ,psiN := AutomorphismGroup(N);
    psiN := map< Domain(psiN) -> Codomain(psiN) | x :-> psiN(x^(-1)) >;
    IndentPop();

    OL := RingOfIntegers(L);

    vprint GFC, 1: "compute primes";
    IndentPush();

    primes:=[];
primes := [f[1] : f in Factorization(Discriminant(ON))];
/*  seq := [p :   p in primes | #Decomposition(L1, p) eq 1];
    if #seq eq 0 then
    p0:=findUndecomposedPrime(L1);
    primes:= Sort([p0] cat primes);
    else p0:=Sort(seq)[1];
    end if;*/
     prime:=trivialSclassless(L,L1,N);
    primes:=&cat[prime,primes];
    set:={x: x in primes};
    primes:=[x : x in set];
     seq := [p :   p in primes | #Decomposition(L1, p) eq 1];
if #seq eq 0 then
    p0:=findUndecomposedPrime(L1);
    primes:= Sort([p0] cat primes);
    else p0:=Sort(seq)[1];
    end if;
   S := &cat([  [Ideal(x[1]) : x in Decomposition(N,p)]  : p in primes]);
    vprint GFC, 1: primes;
    IndentPop();

    vprint GFC, 1: "compute S-units and its G-action";
    IndentPush();
    // compute S-Units and G-action
    vtime GFC, 1: US, mUS := SUnitGroup(S);
    GammaSeq := [sig : sig in Gamma];
    vtime GFC, 1: sigUS := SUnitAction(mUS, [psiN(sig) : sig in GammaSeq],S);
    psiUS := map< Gamma -> Aut(US) | sig :-> sigUS[Index(GammaSeq,sig)] >;

  H := FixedGroup(N,L);
    K := [ Kernel(Transpose(HorizontalJoin(
        Transpose(Matrix([  Eltseq(US.i @ psiUS(h) - US.i)  :  i in [1..#Generators(US)]])), D)))
        : h in H ]
        where D := DiagonalMatrix([Order(US.i) :  i in [1..#Generators(US)] ]);
    USL := &meet([sub<US| [US!Eltseq(b)[1..#Generators(US)] :  b in Basis(k)]> : k in K]);
mUSL := map< USL -> L | x :-> L!(x @ mUS) >;
 assert &and([ g @ mUS in L : g in Generators(USL)]);
    IndentPop();

    vprint GFC, 1: "Time for set S:", Cputime(t);
    t := Cputime();

    vprint GFC, 1: "construct JN";
    IndentPush();
    lst := [];
    thetaAll := [];

    for p in primes do
        vprint GFC, 1: "prime:", p;
        IndentPush();
        PN := Factorization(p*ON)[1,1];
        piN := UniformizingElement(PN);

        vprint GFC, 2: "compute lattice";
        t := Cputime();
        if RamificationIndex(PN) eq 1 then
            theta := ON!1;
            m := 0;
        else
            theta, m := lattice(PN, piN, psiN);
            for i in [1..2] do
                theta1, m1 := lattice(PN, piN, psiN);
                if m1 lt m then
                    theta := theta1;
                    m := m1;
                end if;
            end for;
        end if;
        Append(~thetaAll, ON!theta);
        vprint GFC, 2: "Time:", Cputime(t);


        vtime GFC, 2: NP, iotaN, psiNP := completion_with_precision(N,PN,psiN, m+10);
        LIST:=[*NP,iotaN,psiNP*];
        GammaP := Domain(psiNP);
        vprint GFC, 2: "compute module";
        vtime GFC, 2: MN, psiMN, qMN := compute_LPmul_modX1(N, PN, psiN,LIST, theta, m);
   //   vtime GFC, 2: MN, psiMN, qMN := compute_LPmul_modX(N, PN, piN, psiN, iotaN, NP, psiNP, theta, m);  
        // induce module
        vprint GFC, 2: "compute induced module";
        H := FixedGroup(N,L);
        //R := [Gamma!x : x in r] where r := leftCosetRepresentatives(H, H meet GammaP);
        indMN, psiIndMN, RN, kappaMN, projMN := inducedModule(MN, psiMN, Gamma);// : RepSys := R);
        diagN := map< N -> indMN | x :->
            &+([ x @ psiN(RN[i]^(-1)) @ iotaN @ qMN @ kappaMN[i] : i in [1..#kappaMN] ]) >;

 H := FixedGroup(N,L);
        K := [ Kernel(Transpose(HorizontalJoin(
            Transpose(Matrix([  Eltseq(indMN.i @ psiIndMN(h) - indMN.i)  :  i in [1..#Generators(indMN)]])), D)))
        : h in H ]
        where D := DiagonalMatrix([Order(indMN.i) :  i in [1..#Generators(indMN)] ]);
        indML := &meet([sub<indMN | [indMN!Eltseq(b)[1..#Generators(indMN)] :  b in Basis(k)]> : k in K]);

   // F:= FreeAbelianGroup(Degree(L));
    //mF:=hom<F-> ML| [ x@iotaN@qMN@Coercion(MN,ML): x in Basis(L)]>;

        K1:= [ Kernel(Transpose(HorizontalJoin(Transpose(Matrix([  Eltseq(MN.i @ psiMN(h) - MN.i) :  i in [1..#Generators(MN)]])), D)))  : h in H ] where D := DiagonalMatrix([Order(MN.i):  i in [1..#Generators(MN)] ]);
 ML := &meet([sub<MN| [MN!Eltseq(b)[1..#Generators(MN)]:  b in Basis(k)]> : k in K1]);
F:= FreeAbelianGroup(Degree(L));
    mF:=hom<F-> ML| [ x@iotaN@qMN@Coercion(MN,ML): x in Basis(L)]>;
    //projML_L := map< indML-> L | x:-> L!Eltseq(&+([x @Coercion(indML,indMN) @ projMN[i]@Coercion(MN,ML)@@mF: i in [1..#projMN]]))> ;  
// projML_L := map< indML-> L | x:-> &*([(indMN!x) @ projMN[i]@@qMN @@iotaN @ Coercion(N,L): i in [1..#projMN]])> ;
         kappaL_ML := map<L->indML | x:->&+([x@Coercion(L,N)@iotaN@qMN@kappaMN[i]@Coercion(indMN,indML) :i in [1..kappaMN]])  >;

  GL, qGL := quo<Gamma| H>;

psiL:= map< GL -> Aut(L) | g :-> hom< L -> L | L.1 @ Coercion(L,N) @ psiN(g@@ qGL) @ Coercion(N,L) > >;
PL := Factorization(p*RingOfIntegers(L))[1,1];
theta, m := lattice(PL, UniformizingElement(PL), psiL);
 LP, iotaL, psiLP := completion_with_prec(L,PL,psiL, m+10);
 LIST:=[*LP,iotaL,psiLP*];
 GammaPL := Domain(psiLP);
ml, psiml, qml := compute_LPmul_modX1(L, PL, psiL,LIST, theta,m);
 indml, psiIndml, rl, kappaml, projml := inducedModule(ml, psiml,GL);
//assert Ngens(indML) eq Ngens(indml);
//inc:=hom<indml->indML| [indML.i: i in [1..Ngens(indML)]]>;
//E,mE := MultiplicativeGroup(L);
//F:= FreeAbelianGroup(Ngens(E));
//mf:= hom<F->indML|  [&+([(L!Eltseq(E.j@mE))@iotaL@qml@kappaml[i]@inc: i in [1..#kappaml]]): j in [1..Ngens(E)] ]>;
projML_L:= hom<indml ->L| x:-> (&+([x @projml[i]@@qml:  i in [1..#projml]]))@@iotaL>;
diagL:= map<L-> indml| x :-> &+ ( [ x@psiL(rl[i]^(-1)) @iotaL @ kappaml[i] : i in [1..#kappaml]] )>;

       assert (N!L.1) @ diagN in indML;

       if p ne p0 then
            // trivial cocycle for this
            c2 := map< car<Gamma, Gamma> -> indMN | x :-> Zero(indMN) >;
        else
            vprint GFC, 2: "compute cocycle, prec =", m;
            // compute cocycle for p
            H := FixedGroup(N,L1);
            C, qC := quo< Gamma | H>;
            //psiL1 := map< C -> Aut(L1) | g :-> Coercion(L1,N) * psiN(g @@ qC) * Coercion(N,L1) >;
            psiL1 := map< C -> Aut(L1) | g :->
                hom< L1 -> L1 | L1.1 @ Coercion(L1,N) @ psiN(g @@ qC) @ Coercion(N,L1) >
            >;

            // compute ML1
            K := [ Kernel(Transpose(HorizontalJoin(
                Transpose(Matrix([  Eltseq(indMN.i @ psiIndMN(h) - indMN.i)  :  i in [1..#Generators(indMN)]])), D)))
                : h in H ]
                where D := DiagonalMatrix([Order(indMN.i) :  i in [1..#Generators(indMN)] ]);
            indML1 := &meet([sub<indMN | [indMN!Eltseq(b)[1..#Generators(indMN)] :  b in Basis(k)]> : k in K]);
            psiIndML1 := map< C -> Aut(indML1) |
                sig :-> Coercion(indML1, indMN)*psiIndMN(sig @@ qC)*Coercion(indMN,indML1) >;

            // compute completion of L1
            PL1 := Factorization(p*RingOfIntegers(L1))[1,1];
            //print "completion with sufficient precicion for computations up to precision ", m+10;
            vprint GFC, 2: "compute completion, prec =", m+10;
            L1P, iotaL1, psiL1P := completion_with_prec(L1,PL1,psiL1, m+10);
            //L1P, iotaL1 := Completion(L1, PL1 : Precision := 300); //Max(100,m*2));
            //psiL1P := map< C -> Aut(L1P) | g :-> iotaL1^(-1) * psiL1(g) * iotaL1 >;
            // cocycle C x C -> L1P
            //SetVerbose("CocycleLFC", 1);
            // c := CocycleLFC(L1P, pAdicField(L1P), m+5 : psi := psiL1P);
            if p gt 50 then
             c := CLocalFundamentalClassSerre_check(L1P, pAdicField(L1P), m+5 : psi := psiL1P);
            else c :=CLocalFundamentalClassSerre(L1P, pAdicField(L1P), m+5 : psi := psiL1P);
            end if;
            // inflation
            c2 := map< car<Gamma,Gamma> -> indMN | x :-> c(x[1]@qC, x[2]@qC) @@ iotaL1 @ Coercion(L1,N) @ diagN>;
            vprint GFC, 2: "test cocycle";
            vtime GFC, 2: assert testCocycleGenerators(c2, psiIndMN );
            c2 := map< Domain(c2) -> Codomain(c2) | x:-> c2(x[2]^(-1), x[1]^(-1)) >;
 end if;

        diagN := mUS*diagN;
//Append(~lst, [* indML, psiIndML, diagL, c2, projML, qML, iotaL,kappaML  *]);
       Append(~lst, [* indML, indMN, psiIndMN, diagN, c2, projML_L,kappaL_ML, indml, diagL, qMN, iotaN,kappaMN *]);

        IndentPop();
    end for;

  // infinite places
    vprint GFC, 1: "modules for infinite places";
    assert &and([ IsReal(inf) : inf in InfinitePlaces(N) ]);
    psiM := map< sub<Gamma | Id(Gamma)> -> Aut(US) | sig :-> hom< US -> US | [US.i : i in [1..#Generators(US)]]> >;
    indMN, psiIndMN, RN, kappaMN, projMN := inducedModule(US, psiM, Gamma);
    diagN := map< US -> indMN | x :->
            &+([ x @ psiUS(RN[i]^(-1)) @ kappaMN[i] : i in [1..#kappaMN] ]) >;
    c2 := map< car<Gamma, Gamma> -> indMN | x :-> Zero(indMN) >;
    // Fix-module by H
    H := FixedGroup(N,L);
    K := [ Kernel(Transpose(HorizontalJoin(
        Transpose(Matrix([  Eltseq(indMN.i @ psiIndMN(h) - indMN.i)  :  i in [1..#Generators(indMN)]])), D)))
        : h in H ]
        where D := DiagonalMatrix([Order(indMN.i) :  i in [1..#Generators(indMN)] ]);
    indML := &meet([sub<indMN | [indMN!Eltseq(b)[1..#Generators(indMN)] :  b in Basis(k)]> : k in K]);
    assert &and([ x @ diagN in indML : x in Generators(USL)]);

    Append(~lst, [* indML, indMN, psiIndMN, diagN, c2 *] );
    IndentPop();

vprint GFC, 1: "Time:", Cputime(t);
    t := Cputime();

    // Finitely generated idele group
    vprint GFC, 1: "compute idele group of N";
    IndentPush();
    JN, inclJN, projJN := DirectSum([o[2] : o in lst]);
    // recompute projections
    vtime GFC, 1: projJN := [ hom< Domain(p) -> Codomain(p) | [ p(JN.i) : i in [1..#Generators(JN)]] >  : p in projJN ];
       vtime GFC, 1: actJN := [ hom< JN -> JN |
        [&+( [ JN.j @ projJN[k] @ lst[k,3](sig) @ inclJN[k] : k in [1..#lst]]) : j in [1..#Generators(JN)]]
        > :  sig in GammaSeq];
    psiJN := map< Gamma -> Aut(JN) | sig :-> actJN[ Index(GammaSeq, sig) ] >;

    gamma := map< car<Gamma, Gamma> -> JN | x :-> &+([ x @ lst[i,5] @ inclJN[i]  : i in [1..#lst] ]) >;
    //gammaL := map< Domain(gamma) -> Codomain(gamma) | x :-> gamma(x[2]^(-1), x[1]^(-1)) >;
    //time testCocycleGenerators(gammaL, psiJN);
    IndentPop();

 vprint GFC, 1: "Time:", Cputime(t);
    t := Cputime();

    vprint GFC, 1: "compute idele class group of N";
    IndentPush();
    // diagonal embedding of S-units
    embJN := map< US -> JN | x :-> &+([ x @ lst[i,4] @ inclJN[i] : i in [1..#lst]] ) >;
    // factor out S-Units diagonally
    vtime GFC, 1: B := [g @ embJN : g in Generators(US)];
    CN, qCN := quo<JN | B>;
    psiCN := map< Gamma -> Aut(CN) | sig :-> Inverse(qCN)*psiJN(sig)*qCN >;
    //gammaL := map< Domain(gamma) -> CN | x :-> gamma(x[2]^(-1), x[1]^(-1)) @ qCN >;
    //time testCocycleGenerators(gammaL, psiCN);
    IndentPop();
//"till here works well in 260 seconds around for S3":

 vprint GFC, 1: "compute cohomology of N";
    IndentPush();
    // compute cohomology
    // make right actions
    psiCNr := map< Gamma -> Aut(CN) | g :-> psiCN(g^(-1)) >;
    vtime GFC, 1: CohN := CohomologyModule(Gamma, CN, psiCNr);
    f1CN := map< CN -> RSpace(Integers(),Dimension(CohN)) | x:-> Eltseq(x), y:-> CN!Eltseq(y) >;
    // second cohom. group
    //time H2N := CohomologyGroup(CohN,2);
    vtime GFC, 1: H1N := CohomologyGroup(CohN,1);

    gammaC := map< car<Gamma, Gamma> -> CN | x :-> x @ gamma @ qCN >;

    IndentPop();
//"till here also works well in 360 seconds around for S3":    

vprint GFC, 1: "Time for cohomology of N:", Cputime(t);
    t := Cputime();

    vprint GFC, 1: "compute idele group of L";
    // Cohomology of L
    JL, inclJL, projJL := DirectSum([o[1] : o in lst]);

    embLN := map< JL -> JN |
        x :-> &+([ x @ projJL[i] @ Coercion(lst[i,1], lst[i,2]) @ inclJN[i] : i in [1..#lst]]),
        y :-> &+([ y @ projJN[i] @ Coercion(lst[i,2], lst[i,1]) @ inclJL[i] : i in [1..#lst]])
    >;
    G, qG := quo< Gamma | FixedGroup(N,L) >;
    psiJL := map< G -> Aut(JL) | sig :-> embLN * (sig @@ qG @ psiJN) * Inverse(embLN) >;

     vprint GFC, 1: "compute idele class group of L";
    IndentPush();
    vtime GFC, 1: B := [g @ embJN @@ embLN : g in Generators(USL)];
    CL, qCL := quo<JL | B>;

 psiCL := map< G -> Aut(CL) | sig :-> Inverse(qCL)*psiJL(sig)*qCL >;
    IndentPop();

    vprint GFC, 1: "compute cohomology of L";
    IndentPush();
    // compute cohomology
    // make right actions
    psiCLr := map< G -> Aut(CL) | g :-> psiCL(g^(-1)) >;
    vtime GFC, 1: CohL := CohomologyModule(G, CL, psiCLr);
    // second cohom. group
    vtime GFC, 1: H2L := CohomologyGroup(CohL,2);
    f1CL := map< CL -> RSpace(Integers(),Dimension(CohL)) | x:-> Eltseq(x), y:-> CL!Eltseq(y) >;
    IndentPop();


    vprint GFC, 1: "Time for all the computation for L:", Cputime(t);
    t := Cputime();

     inclUSJL := map< USL -> JL | x :-> (US!x) @ diagN @ inclJL[#inclJL] >;

    comp := rec<GFCcomp |
        CohL := CohL, f1CL := f1CL, //gfcId := gfcId,
        CL := CL, psiCL := psiCL, qCL := qCL,
        primes := primes, US:= USL, mUS := mUSL,
        //kappaInf := kappaML, RepInf := RL, inclJL := inclJL,
        inclUSJL := inclUSJL,
        theta := thetaAll >;

     Req:=[* inclJL, projJL,lst, qG,gammaC,CN,qCN,embLN,CohN,primes,f1CN *];


vprint GFC, 1: "find global fundamental class of L";
    IndentPush();
   for k in [ i : i in [1..Degree(L)] | GCD(i,Degree(L)) eq 1 ] do
    // for k in [ i : i in [1..Degree(L)]] do
     vprintf GFC, 1: ".";
        c := TwoCocycle(CohL, k*H2L.1);
        c2 := map< car< G, G> -> CL | x :-> c(<x[1],x[2]>) @@ f1CL >;
        c3 := map< car< Gamma, Gamma> -> CN | x :-> c2(x[1]@qG,x[2]@qG) @@ qCL @ embLN @ qCN>;
        //c4 := func< x | c3(x) @ f1CN>;
        dif := map< Domain(c3) -> Codomain(c3) | g :-> gammaC(g)-c3(g) >;
        bool, prog := IsTwoCoboundary(CohN, func< x | dif(x[1],x[2]) @ f1CN >);
        if bool then
            vprint GFC, 1: " found.";
            IndentPop();
            comp`gfcId := k*H2L.1;
           return CohL, f1CL, k*H2L.1, comp,Req;
        end if;
    end for;
    vprint GFC, 1: " failed.";
    IndentPop();
    error "Global fundamental class could not be found!!";

end intrinsic;
  


