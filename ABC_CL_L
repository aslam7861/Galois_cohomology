

LP,iotaL:=Completion(OL,PL:Precision:= 100);
LP`DefaultPrecision;
Factorisation(p*OL)[1,1];
    piL := UniformizingElement(PL);
 GammaP := [g : g in GL| &and([  psiL(g)(x) in PL   : x in Generators(PL)]) ];
        Gammap := sub< GL | GammaP>;
        psiLP := map< Gammap -> Aut(LP) | g :-> iotaL^(-1) * psiL(g) * iotaL >;
        LIST:=[*LP,iotaL,psiLP*];
psiL(GL.1)(piL);
    theta, m := lattice(PL, UniformizingElement(PL), psiL);
ML, psiML, qML := compute_LPmul_modX1(L, PL, psiL,LIST, theta, m);
m:=18
ML, psiML, qML := compute_LPmul_modX1(L, PL, psiL,LIST, theta, m);
m:=18;
ML, psiML, qML := compute_LPmul_modX1(L, PL, psiL,LIST, theta, m);
ML;
































intrinsic gfcCompositumcl(L::FldNum, L1::FldNum) -> ModCoho, Map, ModTupRngElt, Rec
{ Given an arbitrary Galois extension L/Q and a cyclic extension L1/Q
  of the same degree, this method computes then global fundamental
  class of L/Q.
}

   // require IsCyclic(L1) and Degree(L) eq Degree(L1) :
     //       "Second number field must be cyclic and of the same degree!";
require IsCyclic(L1):"Second number field must be cyclic";
    t := Cputime();

    vprint GFC, 1: "compute composite field";
    IndentPush();
    vtime GFC, 1: N := OptimizedRepresentation(Compositum(L,L1));
    assert IsTotallyReal(N);
    ON := RingOfIntegers(N);

    Gamma, _ ,psiN := AutomorphismGroup(N);
    psiN := map< Domain(psiN) -> Codomain(psiN) | x :-> psiN(x^(-1)) >;
    IndentPop();

    OL := RingOfIntegers(L);

    vprint GFC, 1: "compute primes";
    IndentPush();
    
    primes:=[];
primes := [f[1] : f in Factorization(Discriminant(ON))];
/*  seq := [p :   p in primes | #Decomposition(L1, p) eq 1];
    if #seq eq 0 then
    p0:=findUndecomposedPrime(L1);
    primes:= Sort([p0] cat primes);
    else p0:=Sort(seq)[1];
    end if;*/
     prime:=trivialSclassless(L,L1,N);
    primes:=&cat[prime,primes];
    set:={x: x in primes};
    primes:=[x : x in set];
     seq := [p :   p in primes | #Decomposition(L1, p) eq 1];
if #seq eq 0 then
    p0:=findUndecomposedPrime(L1);
    primes:= Sort([p0] cat primes);
    else p0:=Sort(seq)[1];
    end if;

// vtime GFC, 2: primes := trivialSClassNumberPrimes(N : primes := primes);
    S := &cat([  [Ideal(x[1]) : x in Decomposition(N,p)]  : p in primes]);
    vprint GFC, 1: primes;
    IndentPop();

    vprint GFC, 1: "compute S-units and its G-action";
    IndentPush();
    // compute S-Units and G-action
    vtime GFC, 1: US, mUS := SUnitGroup(S);
    GammaSeq := [sig : sig in Gamma];
    vtime GFC, 1: sigUS := SUnitAction(mUS, [psiN(sig) : sig in GammaSeq],S);
    psiUS := map< Gamma -> Aut(US) | sig :-> sigUS[Index(GammaSeq,sig)] >;
    // S-units for L
    //H := FixedGroup(N,L);
    //K:=[ Kernel(VerticalJoin(Matrix([  Eltseq(US.i @ SUnitAction(mUS, psiN(h),S) - US.i)  :  i in [1..#Generators(US)]]),Transpose(D))) : h in H ] where D := DiagonalMatrix([Order(US.i) :  i in [1..#Generators(US)] ]);
    //K := [ Kernel(Transpose(HorizontalJoin(
    //Transpose(Matrix([  Eltseq(US.i @ SUnitAction(mUS, psiN(h),S) - US.i)  :  i in [1..#Generators(US)]])), D)))
    //: h in H ]
    //where D := DiagonalMatrix([Order(US.i) :  i in [1..#Generators(US)] ]); "is same as the next";
   
   
   
   
   H := FixedGroup(N,L);
  GL, qGL := quo<Gamma| H>;
  //GL:= sub<Gamma|[x@@qGL: x in GL]>;// this does not hold;
  psiL:= map< GL -> Aut(L) | g :-> hom< L -> L | L.1 @ Coercion(L,N) @ psiN(g@@qG) @ Coercion(N,L) > >;
  K := [ Kernel(Transpose(HorizontalJoin(
        Transpose(Matrix([  Eltseq(US.i @ psiUS(h) - US.i)  :  i in [1..#Generators(US)]])), D)))
        : h in H ]
        where D := DiagonalMatrix([Order(US.i) :  i in [1..#Generators(US)] ]);
    USL := &meet([sub<US| [US!Eltseq(b)[1..#Generators(US)] :  b in Basis(k)]> : k in K]);

 assert &and([ g @ mUS in L : g in Generators(USL)]);
    IndentPop();

    vprint GFC, 1: "Time for set S:", Cputime(t);
    t := Cputime();

    vprint GFC, 1: "construct JN";
    IndentPush();
    lst := [];
    LST := [];
    thetaAll := [];

    for p in primes do
        vprint GFC, 1: "prime:", p;
        IndentPush();
        PN := Factorization(p*ON)[1,1];
        piN := UniformizingElement(PN);

        vprint GFC, 2: "compute lattice";
        t := Cputime();
        if RamificationIndex(PN) eq 1 then
            theta := ON!1;
            m := 0;
        else
            theta, m := lattice(PN, piN, psiN);
            for i in [1..2] do
                theta1, m1 := lattice(PN, piN, psiN);
                if m1 lt m then
                    theta := theta1;
                    m := m1;
                end if;
            end for;
        end if;
        Append(~thetaAll, ON!theta);
        vprint GFC, 2: "Time:", Cputime(t);

        /*
        print "compute completion, prec =", Max(100,m*2);
        NP, iotaN := Completion(N, PN : Precision := Max(100,m*2));
        GammaP := [g : g in Gamma | &and([  psiN(g)(x) in PN   : x in Generators(PN)]) ];
        GammaP := sub< Gamma | GammaP>;
        psiNP := map< GammaP -> Aut(NP) | g :-> iotaN^(-1) * psiN(g) * iotaN >;
        */
        //print "completion with sufficient precicion for computations up to precision ", m+10;
        vprint GFC, 2: "compute completion, prec =", m+10;
        vtime GFC, 2: NP, iotaN, psiNP := completion_with_precision(N,PN,psiN, m+10);
        LIST:=[*NP,iotaN,psiNP*];
        GammaP := Domain(psiNP);
        vprint GFC, 2: "compute module";
        vtime GFC, 2: MN, psiMN, qMN := compute_LPmul_modX1(N, PN, psiN,LIST, theta, m);
   //   vtime GFC, 2: MN, psiMN, qMN := compute_LPmul_modX(N, PN, piN, psiN, iotaN, NP, psiNP, theta, m);  
	// induce module
        vprint GFC, 2: "compute induced module";
        H := FixedGroup(N,L);
        //R := [Gamma!x : x in r] where r := leftCosetRepresentatives(H, H meet GammaP);
        indMN, psiIndMN, RN, kappaMN, projMN := inducedModule(MN, psiMN, Gamma);// : RepSys := R);
        diagN := map< N -> indMN | x :->
            &+([ x @ psiN(RN[i]^(-1)) @ iotaN @ qMN @ kappaMN[i] : i in [1..#kappaMN] ]) >;

// H := FixedGroup(N,L);
        K := [ Kernel(Transpose(HorizontalJoin(
            Transpose(Matrix([  Eltseq(indMN.i @ psiIndMN(h) - indMN.i)  :  i in [1..#Generators(indMN)]])), D)))
        : h in H ]
        where D := DiagonalMatrix([Order(indMN.i) :  i in [1..#Generators(indMN)] ]);
        indML := &meet([sub<indMN | [indMN!Eltseq(b)[1..#Generators(indMN)] :  b in Basis(k)]> : k in K]);

   // F:= FreeAbelianGroup(Degree(L));
    //mF:=hom<F-> ML| [ x@iotaN@qMN@Coercion(MN,ML): x in Basis(L)]>;

        K1:= [ Kernel(Transpose(HorizontalJoin(Transpose(Matrix([  Eltseq(MN.i @ psiMN(h) - MN.i) :  i in [1..#Generators(MN)]])), D)))  : h in H ] where D := DiagonalMatrix([Order(MN.i):  i in [1..#Generators(MN)] ]);
 ML := &meet([sub<MN| [MN!Eltseq(b)[1..#Generators(MN)]:  b in Basis(k)]> : k in K1]);
F:= FreeAbelianGroup(Degree(L));
    mF:=hom<F-> ML| [ x@iotaN@qMN@Coercion(MN,ML): x in Basis(L)]>;
    //projML_L := map< indML-> L | x:-> L!Eltseq(&+([x @Coercion(indML,indMN) @ projMN[i]@Coercion(MN,ML)@@mF: i in [1..#projMN]]))> ;  
// projML_L := map< indML-> L | x:-> &*([(indMN!x) @ projMN[i]@@qMN @@iotaN @ Coercion(N,L): i in [1..#projMN]])> ;
         kappaL_ML := map<L->indML | x:->&+([x@Coercion(L,N)@iotaN@qMN@kappaMN[i]@Coercion(indMN,indML) :i in [1..#kappaMN]])  >;

//  GL, qGL := quo<Gamma| H>;

PL := Factorization(p*RingOfIntegers(L))[1,1]; 
theta, m := lattice(PL, UniformizingElement(PL), psiL); 
 LP, iotaL, psiLP := completion_with_prec(L,PL,psiL, m+10);
 LIST:=[*LP,iotaL,psiLP*];    
 GammaPL := Domain(psiLP); 
ml, psiml, qml := compute_LPmul_modX1(L, PL, psiL,LIST, theta,m);
 indml, psiIndml, rl, kappaml, projml := inducedModule(ml, psiL,GL);
//assert Ngens(indML) eq Ngens(indml);
//inc:=hom<indml->indML| [indML.i: i in [1..Ngens(indML)]]>;
//E,mE := MultiplicativeGroup(L);
//F:= FreeAbelianGroup(Ngens(E));
//mf:= hom<F->indML|  [&+([(L!Eltseq(E.j@mE))@iotaL@qml@kappaml[i]@inc: i in [1..#kappaml]]): j in [1..Ngens(E)] ]>;
//projML_L:= hom<indML ->L| x:-> (&+([x@@inc @projml[i]@@qml:  i in [1..#projml]]))@@iotaL>;
projML_L:= hom<indml ->L| x:-> (&+([x @projml[i]@@qml:  i in [1..#projml]]))@@iotaL>;
diagL:= map<L-> indml| x :-> &+ ( [ x@psiL(rl[i]^(-1)) @iotaL@qml @ kappaml[i] : i in [1..#kappaml]] )>;
F:= FreeAbelianGroup(Ngens(indml));
mf:=hom<F-> indML| [&+([indml.i @projML_L@iotaN@qMN@kappaMN[i]@Coercion(indMN,indML):i in [1..#kappaMN]]): j in [1..Ngens(indml)]]>;    
//mf:=hom<F-> indML| [indml.i @projML_L@kappaML_L: i in [1..Ngens(indml)]]>;
proj_ML_ml:= hom<indML-> indml| x:-> indml!Eltseq(x@@mf)>;  
proj_ml_ML:= hom<indml-> indML| x:->  (F!Eltseq(x))@mf>;  

     assert (N!L.1) @ diagN in indML;   
        /*
        H := FixedGroup(N,L1);
        K := [ Kernel(Transpose(HorizontalJoin(
            Transpose(Matrix([  Eltseq(indMN.i @ psiIndMN(h) - indMN.i)  :  i in [1..#Generators(indMN)]])), D)))
            : h in H ]
            where D := DiagonalMatrix([Order(indMN.i) :  i in [1..#Generators(indMN)] ]);
        indML1 := &meet([sub<indMN | [indMN!Eltseq(b)[1..#Generators(indMN)] :  b in Basis(k)]> : k in K]);
        assert (N!L1.1) @ diagN in indML1;
        */

        if p ne p0 then
            // trivial cocycle for this
            c2 := map< car<Gamma, Gamma> -> indMN | x :-> Zero(indMN) >;
        else
            vprint GFC, 2: "compute cocycle, prec =", m;
            // compute cocycle for p
            H := FixedGroup(N,L1);
            C, qC := quo< Gamma | H>;
            //psiL1 := map< C -> Aut(L1) | g :-> Coercion(L1,N) * psiN(g @@ qC) * Coercion(N,L1) >;
            psiL1 := map< C -> Aut(L1) | g :->
                hom< L1 -> L1 | L1.1 @ Coercion(L1,N) @ psiN(g @@ qC) @ Coercion(N,L1) >
            >;

            // compute ML1
            K := [ Kernel(Transpose(HorizontalJoin(
                Transpose(Matrix([  Eltseq(indMN.i @ psiIndMN(h) - indMN.i)  :  i in [1..#Generators(indMN)]])), D)))
                : h in H ]
                where D := DiagonalMatrix([Order(indMN.i) :  i in [1..#Generators(indMN)] ]);
            indML1 := &meet([sub<indMN | [indMN!Eltseq(b)[1..#Generators(indMN)] :  b in Basis(k)]> : k in K]);
            psiIndML1 := map< C -> Aut(indML1) |
                sig :-> Coercion(indML1, indMN)*psiIndMN(sig @@ qC)*Coercion(indMN,indML1) >;

            // compute completion of L1
            PL1 := Factorization(p*RingOfIntegers(L1))[1,1];
            //print "completion with sufficient precicion for computations up to precision ", m+10;
            vprint GFC, 2: "compute completion, prec =", m+10;
            L1P, iotaL1, psiL1P := completion_with_prec(L1,PL1,psiL1, m+10);
            //L1P, iotaL1 := Completion(L1, PL1 : Precision := 300); //Max(100,m*2));
            //psiL1P := map< C -> Aut(L1P) | g :-> iotaL1^(-1) * psiL1(g) * iotaL1 >;
            // cocycle C x C -> L1P
            //SetVerbose("CocycleLFC", 1);
            // c := CocycleLFC(L1P, pAdicField(L1P), m+5 : psi := psiL1P);
	    if p gt 50 then
             c := CLocalFundamentalClassSerre_check(L1P, pAdicField(L1P), m+5 : psi := psiL1P);
            else c :=CLocalFundamentalClassSerre(L1P, pAdicField(L1P), m+5 : psi := psiL1P);
	    end if;
	    // inflation
            c2 := map< car<Gamma,Gamma> -> indMN | x :-> c(x[1]@qC, x[2]@qC) @@ iotaL1 @ Coercion(L1,N) @ diagN>;
            vprint GFC, 2: "test cocycle";
            vtime GFC, 2: assert testCocycleGenerators(c2, psiIndMN );
            c2 := map< Domain(c2) -> Codomain(c2) | x:-> c2(x[2]^(-1), x[1]^(-1)) >;
 end if;

        diagN := mUS*diagN;
	diagN := mUSL*diagL;
       Append(~LST,[* indml, psiIndml,diagL , proj_ml_ML, proj_ML_ml*]);
//Append(~lst, [* indML, psiIndML, diagL, c2, projML, qML, iotaL,kappaML  *]);
       Append(~lst, [* indML, indMN, psiIndMN, diagN, c2, projML_L,kappaL_ML, qMN, iotaN,kappaMN,proj_ML_ml *]);
      //Append(~lst, [* indML, indMN, psiIndMN, diagN, c2 *]);
        IndentPop();
    end for;

  // infinite places
    vprint GFC, 1: "modules for infinite places";
    assert &and([ IsReal(inf) : inf in InfinitePlaces(N) ]);
    psiM := map< sub<Gamma | Id(Gamma)> -> Aut(US) | sig :-> hom< US -> US | [US.i : i in [1..#Generators(US)]]> >;
    psim := map< sub<GL | Id(GL)> -> Aut(USL) | sig :-> hom< USL -> USL | [USL.i : i in [1..#Generators(USL)]]> >;
        indml, psiIndml, rl, kappaml, projml := inducedModule(USL, psim, GL);
   diagL := map< USL -> indml | x :->
            &+([ x @ psiUS((rl[i]^(-1))@@qGL) @ kappaml[i] : i in [1..#kappaml] ]) >;
    indMN, psiIndMN, RN, kappaMN, projMN := inducedModule(US, psiM, Gamma);
    diagN := map< US -> indMN | x :->
            &+([ x @ psiUS(RN[i]^(-1)) @ kappaMN[i] : i in [1..#kappaMN] ]) >;
    c2 := map< car<Gamma, Gamma> -> indMN | x :-> Zero(indMN) >;
    // Fix-module by H
    H := FixedGroup(N,L);
    K := [ Kernel(Transpose(HorizontalJoin(
        Transpose(Matrix([  Eltseq(indMN.i @ psiIndMN(h) - indMN.i)  :  i in [1..#Generators(indMN)]])), D)))
        : h in H ]
        where D := DiagonalMatrix([Order(indMN.i) :  i in [1..#Generators(indMN)] ]);
    indML := &meet([sub<indMN | [indMN!Eltseq(b)[1..#Generators(indMN)] :  b in Basis(k)]> : k in K]);
    assert &and([ x @ diagN in indML : x in Generators(USL)]);
   Append(~LST,[* indml, psiIndml,diagL *]);
    Append(~lst, [* indML, indMN, psiIndMN, diagN, c2 *] );
    IndentPop();

vprint GFC, 1: "Time:", Cputime(t);
    t := Cputime();

    // Finitely generated idele group
    vprint GFC, 1: "compute idele group of N";
    IndentPush();
    JN, inclJN, projJN := DirectSum([o[2] : o in lst]);
    // recompute projections
    vtime GFC, 1: projJN := [ hom< Domain(p) -> Codomain(p) | [ p(JN.i) : i in [1..#Generators(JN)]] >  : p in projJN ];
    //projJN := [ hom< JN -> lst[k,2] |
       // [ Index(seq,i) eq 0 select lst[k,2]!0 else lst[k,2].(Index(seq,i))  : i in [1..#Generators(JN)]]
      //  >
    //    where seq := [Index(Eltseq(inclJN[k](lst[k,2].i)),1) : i in [1..#Generators(lst[k,2])]]
  //      : k in [1..#lst]];

    vtime GFC, 1: actJN := [ hom< JN -> JN |
        [&+( [ JN.j @ projJN[k] @ lst[k,3](sig) @ inclJN[k] : k in [1..#lst]]) : j in [1..#Generators(JN)]]
        > :  sig in GammaSeq];
    psiJN := map< Gamma -> Aut(JN) | sig :-> actJN[ Index(GammaSeq, sig) ] >;

    gamma := map< car<Gamma, Gamma> -> JN | x :-> &+([ x @ lst[i,5] @ inclJN[i]  : i in [1..#lst] ]) >;
    //gammaL := map< Domain(gamma) -> Codomain(gamma) | x :-> gamma(x[2]^(-1), x[1]^(-1)) >;
    //time testCocycleGenerators(gammaL, psiJN);
    IndentPop();

 vprint GFC, 1: "Time:", Cputime(t);
    t := Cputime();

    vprint GFC, 1: "compute idele class group of N";
    IndentPush();
    // diagonal embedding of S-units
    embJN := map< US -> JN | x :-> &+([ x @ lst[i,4] @ inclJN[i] : i in [1..#lst]] ) >;
    // factor out S-Units diagonally
    vtime GFC, 1: B := [g @ embJN : g in Generators(US)];
    CN, qCN := quo<JN | B>;
    psiCN := map< Gamma -> Aut(CN) | sig :-> Inverse(qCN)*psiJN(sig)*qCN >;
    //gammaL := map< Domain(gamma) -> CN | x :-> gamma(x[2]^(-1), x[1]^(-1)) @ qCN >;
    //time testCocycleGenerators(gammaL, psiCN);
    IndentPop();
//"till here works well in 260 seconds around for S3":

 vprint GFC, 1: "compute cohomology of N";
    IndentPush();
    // compute cohomology
    // make right actions
    psiCNr := map< Gamma -> Aut(CN) | g :-> psiCN(g^(-1)) >;
    vtime GFC, 1: CohN := CohomologyModule(Gamma, CN, psiCNr);
    f1CN := map< CN -> RSpace(Integers(),Dimension(CohN)) | x:-> Eltseq(x), y:-> CN!Eltseq(y) >;
    // second cohom. group
    //time H2N := CohomologyGroup(CohN,2);
    vtime GFC, 1: H1N := CohomologyGroup(CohN,1);

    gammaC := map< car<Gamma, Gamma> -> CN | x :-> x @ gamma @ qCN >;
    //gfcId := IdentifyTwoCocycle(CohN, func< x | gammaC(x[1],x[2]) @ f1CN >);
    IndentPop();
//"till here also works well in 360 seconds around for S3":    

vprint GFC, 1: "Time for cohomology of N:", Cputime(t);
    t := Cputime();

    vprint GFC, 1: "compute idele group of L";
    // Cohomology of L
    JL, inclJL, projJL := DirectSum([o[1] : o in lst]);
    jl, incljl, projjl := DirectSum([o[1] : o in LST]);
     embjl := map< USL -> jl | x :-> &+([ x @ LST[i,3] @ incljl[i] : i in [1..#lst]] ) >; 
gammaseq:= [x: x in GL];
actjl := [ hom< jl -> jl |
        [&+( [ jl.j @ projjl[k] @ LST[k,2](sig) @ incljl[k] : k in [1..#LST]]) : j in [1..#Generators(jl)]]
        > :  sig in gammaseq];   

 psijl := map< GL -> Aut(jl) | sig :-> actjl[ Index(gammaseq, sig) ] >;  
 embjl := map< USL -> jl | x :-> &+([ x @ LST[i,3] @ incljl[i] : i in [1..#LST]] ) >;
 vtime GFC, 1: b := [g @ embjl : g in Generators(USL)];
 cl, qcl := quo<jl | b>;
psicl := map< GL -> Aut(cl) | sig :-> Inverse(qcl)*psijl(sig)*qcl >;
psiclr := map< GL -> Aut(cl) | g :-> psicl(g^(-1)) >;
    vtime GFC, 1: Cohl := CohomologyModule(GL, cl, psiclr);
    //  psijl := map< GL -> Aut(jl) | sig :-> embLN * (sig @@ qG @ psiJN) * Inverse(embLN) >;
embLN := map< JL -> JN |
        x :-> &+([ x @ projJL[i] @ Coercion(lst[i,1], lst[i,2]) @ inclJN[i] : i in [1..#lst]]),
        y :-> &+([ y @ projJN[i] @ Coercion(lst[i,2], lst[i,1]) @ inclJL[i] : i in [1..#lst]])
    >;
    G, qG := quo< Gamma | FixedGroup(N,L) >;
    psiJL := map< G -> Aut(JL) | sig :-> embLN * (sig @@ qG @ psiJN) * Inverse(embLN) >;

     vprint GFC, 1: "compute idele class group of L";
    IndentPush();
    vtime GFC, 1: B := [g @ embJN @@ embLN : g in Generators(USL)];
    CL, qCL := quo<JL | B>;

 psiCL := map< G -> Aut(CL) | sig :-> Inverse(qCL)*psiJL(sig)*qCL >;
    IndentPop();

    vprint GFC, 1: "compute cohomology of L";
    IndentPush();
    // compute cohomology
    // make right actions
    psiCLr := map< G -> Aut(CL) | g :-> psiCL(g^(-1)) >;
    vtime GFC, 1: CohL := CohomologyModule(G, CL, psiCLr);
    // second cohom. group
    vtime GFC, 1: H2L := CohomologyGroup(CohL,2);
    f1CL := map< CL -> RSpace(Integers(),Dimension(CohL)) | x:-> Eltseq(x), y:-> CL!Eltseq(y) >;
    IndentPop();


    vprint GFC, 1: "Time for all the computation for L:", Cputime(t);
    t := Cputime();

    mUSL := map< USL -> L | x :-> L!(x @ mUS) >;
    inclUSJL := map< USL -> JL | x :-> (US!x) @ diagN @ inclJL[#inclJL] >;

    comp := rec<GFCcomp |
        CohL := CohL, f1CL := f1CL, //gfcId := gfcId,
        CL := CL, psiCL := psiCL, qCL := qCL,
        primes := primes, US:= USL, mUS := mUSL,
        //kappaInf := kappaML, RepInf := RL, inclJL := inclJL,
        inclUSJL := inclUSJL,
        theta := thetaAll >;

     Req:=[* inclJL, projJL,lst, qG,gammaC,CN,qCN,embLN,CohN,primes,f1CN, Cohl *];


vprint GFC, 1: "find global fundamental class of L";
    IndentPush();
   for k in [ i : i in [1..Degree(L)] | GCD(i,Degree(L)) eq 1 ] do
    // for k in [ i : i in [1..Degree(L)]] do
     vprintf GFC, 1: ".";
        c := TwoCocycle(CohL, k*H2L.1);
        c2 := map< car< G, G> -> CL | x :-> c(<x[1],x[2]>) @@ f1CL >;
        c3 := map< car< Gamma, Gamma> -> CN | x :-> c2(x[1]@qG,x[2]@qG) @@ qCL @ embLN @ qCN>;
        //c4 := func< x | c3(x) @ f1CN>;
        dif := map< Domain(c3) -> Codomain(c3) | g :-> gammaC(g)-c3(g) >;
        bool, prog := IsTwoCoboundary(CohN, func< x | dif(x[1],x[2]) @ f1CN >);
        if bool then
            vprint GFC, 1: " found.";
            IndentPop();
            comp`gfcId := k*H2L.1;
           return CohL, f1CL, k*H2L.1, comp,Req;
        end if;
    end for;
    vprint GFC, 1: " failed.";
    IndentPop();
    error "Global fundamental class could not be found!!";

/*
 maps:=[];
   CL_L:=[];
   for i in [1..#primes] do
       h:= hom<car<G, G>->L| x:-> x@TwoCocycle(CohL,gfcId)@@f1CL@@comp`qCL@projJL[i]@lst[i,5,1]@@lst[i,6]@@lst[i,7]>;
       h1:= hom<CL->L| x:-> x@@comp`qCL@projJL[i]@lst[i,5,1]@@lst[i,6]@@lst[i,7],
                       y:-> y@lst[i,7] @ lst[i,6] @lst[i,8,1]@ inclJL[i]@comp`qCL    >;
      Append(~maps,h);
      Append(~CL_L,h1);
   end for;
   //h1:= hom<car<G, G>->L| x:-> x@TwoCoycle(CohL,gfcId)@@f1CL@@comp`qCL@projJL[1]@lst[1,6,1]@@lst[1,5]@@lst[1,7]>;
//Req := [* maps, CL_L, psiJL,inclJL,projJL, kappaML, projML, lst  *] ;
    hom := hom<car<G, G>->L| x:-> x@TwoCocycle(CohL,gfcId)@@f1CL@@comp`qCL@projJL[#primes+1]@lst[#primes+1,5,1]@mUS>;
Append(~maps, hom);
h1:= hom<CL->L| x:-> x@@qCL@projJL[#primes+1]@lst[#primes+1,5,1]@mUS>;
                     //  y:-> y@lst[i,7] @ lst[i,6] @lst[i,8,1]@ inclJL[i]@comp`qCL    >;
Append(~CL_L, h1);


  Req:=[* G,qG,Gamma,gammaC,CL,qCL,CN,qCN,embLN,CohL,CohN,H2L,primes,f1CN,thetaAll *];



H2N := CohomologyGroup(CohN,2);
    gfcId := IdentifyTwoCocycle(CohN, func< x | gammaC(x[1],x[2]) @ f1CN >);
    c := TwoCocycle(CohL, H2L.1);
    c2 := map< car< G, G> -> CL | x :-> c(<x[1],x[2]>) @@ f1CL >;
    c3 := map< car< Gamma, Gamma> -> CN | x :-> c2(x[1]@qG,x[2]@qG) @@ qCL @ embLN @ qCN>;
    c4 := func< x | c3(x) @ f1CN>;
    gfcLid := IdentifyTwoCocycle(CohN, c4);
    gfcL := [k : k in [1..#G] | k*gfcLid eq gfcId ][1] * H2L.1;
    //return CohL, f1CL, gfcL;

return CohL,f1CL,gfcL,comp,Req,H2N;
*/    
end intrinsic;


